# 기본 시작 형식
	public static void main(String [] args) { 	}
	## 새로 만들때 체크하면 자동으로 생성됨.
	## Class 생성시 작성하지 않음.

# 단축키
	import 작성 : ctrl + shift + o
	실행 : alt + shift + x + j
	System.out.println(); : sysout + ctrl + space

# error 
	may not have been initialized
		: 초기화되지 않음(초기값을 갖지 않음.)
		: 지역변수의 경우 초기값이 없음으로 error가 발생함.
		
	cannot be assigned
		: 고정값을 바꾸려할때 발생.(상수를 변경하려할때 발생)
		: final 이 주어진 함수선언은 상수를 만듬(이후에 수정불가)

# 출력
	System.out.println(##);
		## 출력하고자하는 내용작성
		### ln을 제거하면 \n이 없이 출력가능
		### 주소를 출력함.(따라서 Array 내용 출력시 하단 참조)
	
	## 유용한 함수
		arr 출력 : Arrays.deepToString(arr)

# 변수
	## 매개변수
		자료형 ... 변수명 : 인자의 갯수가 유동적일때 사용. **array사용과 흡사.
	
	## 인스턴스 변수(동적변수)
		: 객체를 선언해서 heap 메모리에 저장하는 방식
		: 객체마다 값을 초기화 가능함.
	
	## static 변수(정적변수)
		: 인스턴스 변수를 사용이 객체선언을 해야되는 단점을 해결
		: 객체를 별도로 선언해도 값이 공유됨.
	
	## 상수
		
		

# random(랜덤)값 출력
	Math.random() : 0<x<1 의 범위에서 랜덤추출
		##활용 : (int)Math.random*2 => 0,1 중 하나 랜덤 추출

# String 
	##출력 값 비교
	(java는 출력을 주소로 하기 때문에 주소비교로 들어가므로 별도의 함수가 필요함)
	변수.equals(##)
		## 비교할 문장 입력
	## int => String
		Integer.toString(int)

# 조건식(삼항 연산자)
	조건식 ? 참인결과 : 거짓결과;

# if 문
	if(조건문) { 참일때 출력할 값}
	else if(조건문) {참일때 출력할 값}
	else {거짓일때 출력할 값}

# switch
	## 사용시 주의사항
		1. 조건마다 break; 를 써야한다.(아닐경우 해당 조건 이후로 모두 출력.)
		2. 조건은 == 에 해당한 값을 갖는다. (범위는 if 사용 추천) 
		3. default : 이외 값
		4. equals를 사용하지 않아도 됨.(자동으로 값만 비교)
	## 사용
	switch(조건){
	case 비교값 : 해당조건시 출력값; break;
	case 비교값 : 해당조건시 출력값; break;
	default : 해당조건시 출력값; break;
	}

# 입력값 받기
	import java.util.Scanner;
	Scanner sc = new Scanner(System.in);
	받을변수type 변수명 = sc.next##();
		## 변수type에 맞춰서 적어야함.
	
# 반복문 제한
	: {}를 적지않고 사용가능
	break : 반복문장을 멈춤.
	continue : 밑의 내용을 실행하지 않고 반복위로 돌아감.

# 반복문(for)
	for(변수type 변수; 반복조건; ##){ 반복할 코드 작성 }
	## 한번 진행된 후 변수에 적용할 코드 작성
		ex) 변수를 i로 주었을 경우 i++, i +=2
		
	++ for each
	for(변수type i : 출력변수){ }
		: 출력변수의 하나씩을 받아서 반복실행
		: (제한) 1차원형태만 가능.

# 반복문(while)
	## for와 차이점 :
	    1. 변수를 외부에서 지정
	    2. 변수 변동(ex i++) 또한 {}안에 적어주거나 break를 사용해서 무한루프방지해야함.
		--> continue 등 동시 사용시 무한루프에 빠질 수 있으니 앞에 써주는 습관 필요.

	## 형식
	while(조건문) { 반복출력할 문구 }

  	## do ~ while
	## 형식
	do{조건식의 연산결과가 참일때 연산식, 처음 1번은 무조건 실행}
	while{조건식};

# Array
	## 생성(ex)
		int [] i = {1,2,3,4};
		int [] i = new int {1,2,3,4};
		int [] i = new int [4]
		** 값을 넣지 않을 경우 : 숫자는 0, String은 null **
		
	## 관련함수
		길이 출력 : 변수명.length

# static
	: static을 붙히지 않고 class 선언시 => 사용하기 위해서 객체를 생성해서 사용해야함.
	: 사용할때마다 객체를 생성하지 않기 위해선 static을 붙혀야함.
	## 정적변수 초기화 방법
		1. 생성자
		2. static블럭
			static{초기화할변수명 = 초기값;}
		3. setter
			
# Class
	## 구성요소
		맴버필드 / 생성자(생략시 default 생성자 생성) / 메서드
		
	## 사용시 주의점
		1. public static void main(String [] args) {}를 사용하면 error
		2. Class의 첫번째 글자는 대문자로 하는게 좋음.(변수와 구별하기 위해)
		#### 20210513 Board & Ex10Test######
		3. 값을 직접대입하는 것이 비효율적이기 때문에 변수작성함.
		**방법**
		public void set변수명(자료형 변수명){ 값을넣을변수명 = 변수명;}
			// 대부분 변수명을 동일하게 하기 때문에 값을 넣을 변수명 앞에 this. 을 붙혀서씀.
		4. 값을 불러오는 것 또한 직접값을 가져오지 않음.
		**방법**
		public 자료형 get변수명() { return this.변수명;}
			class 정의시 하단부에 넣음.
		
# private
	private 자료형 변수명;
	: 내부에서는 사용가능, 외부에서는 사용불가능하게 함.
	: 은닉함 => 캠슐화

# 생성자
	public 생성자이름(자료형 변수명, 자료형 변수명 ...){
	this.변수명 = 변수명;
	this.변수명 = 변수명;... }
	## 주의 : 생성자를 작성시 기본생성자 작성해줘야함.
	## 기본생성자(default 생성자) 형태
		public Class명(){ }
	## getter, setter (20210513 Ex15)
		setter : 수정하기 위해서 필요함.(기본생성자에서는 입력까지)
		getter : 값을 출력하기 위해서 필요함.
	## 오버로딩
		: 매개변수(()사이의변수들)의 종류,순서 등을 다르게 같은이름으로 생성할 수 있음.
		// 단 같은 자료형끼리 순서를 바꾸면 순서인식이 불가하므로 error


# 메서드
	## 메서드 4가지 유형
	1) 기본 메서드 : 매개변수 0, 반환 값 0
		public static 자료형 메서드명(자료형 변수명1. 자료형 변수2..){ 변수1,2... 로 코딩 및 출력(return or sysout}
	2) 매개변수 0, 반환 값 X
		public static void 메서드명(자료형 변수명1..){
		** 코딩 // sysout 혹은 변수지정까지 모두 완료해야함. } // 즉, 메서드를 변수로 받을 수 없음
	3) 매개변수 X, 반환 값 0
		public static 자료형 메서드명(){ 코딩 및 출력}
	4) 매개변수 X, 반환 값 X
		public static void 메서드명(){ 코딩 및 출력}
		
	// 정리 : 매개변수가 X == 필드값을 받는다.
		
	## 메서드와 함수 차이점
		class 내에서 정의 : 메서드
		class 외부에서 정의 : 함수
		
	## 오버로딩
		: 매개변수(()사이의변수들)의 종류,순서 등을 다르게 같은이름으로 생성할 수 있음.
		// 단 같은 자료형끼리 순서를 바꾸면 순서인식이 불가하므로 error
		
# 패키지(package)
	: class 파일을 모아둔 폴더
	: class 생성으로 패키지 안에 패키지를 생성시 . 을 이용해서 생성함.(/ 이용하지 않음 주의!!)
	: 다른 폴더의 .class 사용 => import해서 사용

# extends(상속, 확장)
	: 다른 class의 내용을 가져옴.
	public class 작성하는class명 extends 가져올class명{     }
	
	## 오버라이드(override)
		: 상속받은 코드가 문제점을 수정 혹은 재정의 하는 것.
		: 수정한 문구위에 @override라고 적어주는게 좋음.

# java 메모리 구조
	: 3가지로 구분됨(stack / heap / static( =code =data))
	## stack, static 차이
		동적변수 vs 정적변수 // 인스턴스변수 vs 클래스 변수
	stack : 객체 선언시마다 새로운 메모리값을 가짐(copy와 유사)
	static : 객체를 별도 선언에도 동일한 변수를 가져감(원본을 공유함)

# 접근 지정자
	: 접근 지정자에 따라 변수초기화 가능 여부가 판단되기 때문에 이를 보완하고자 setter를 만듬.
	: 종류 : public, private, protected
	## protected : 같은 package안 혹은 상속(extends)으로 사용가능  /  외부사용불가
		     : 기본값
	## public : 어디서든 사용가능
	## private : 상속 또한 불가능.
	
# 개념 
	## 객체지향 특징 정리 찾아서 메모장에 정리할것.
	## 특징 : 캡슐화
